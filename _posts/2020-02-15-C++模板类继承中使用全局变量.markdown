---
title: C++ 模板类继承中使用静态数据成员作为全局变量
layout: post
tag: [CPP, Code]
---

<br/>

C++ 模板类继承中使用静态数据成员作为全局变量，在子类中引用父类的静态数据成员，在初始化它时，不可以使用类构造器初始化列表。

<br/>

**首先定义如下的数据类模板**

```cpp
// fileame : data.h

#pragma once

#include <iostream>
using namespace std;

template<typename T>
struct Data {
public:
    static T data;
    static void show(void) { cout << "Data is : " << data << '\n'; }
};

template <typename T>
T Data<T>::data;

```

<br/>
<br/>

**AddData子类继承并通过引用使用父类（Data）的静态数据 data**  
```cpp
// filename : a.h

#pragma once

#include "data.h"

template <typename T>
struct AddData : public Data<T> {
private:
    T &data = Data<T>::data;
public:
    AddData(T val) { data = val; }  
    //AddData(T val) : data(val) {}
    void set() { data += 2; }
    void change(T val) { data += val; }
    void show(void) { Data<T>::show(); }
};

```

<br/>
<br/>

**MinusData子类继承并通过引用使用父类（Data）的静态数据 data**  
```cpp
// filename : b.h

#pragma once

#include "data.h"

template <typename T>
struct MinusData : public Data<T> {
private:
    T &data = Data<T>::data;

public:
    MinusData(){}
    void change(T val) { data -= val; }
    void show(void) { Data<T>::show(); }
    void showMe(void) { cout << data << '\n'; }
};

```
<br/>
<br/>

**这是测试的Main函数**
```cpp
// filenmae : main.h

#include "a.h"
#include "b.h"

int main(void) {

    AddData<int> ad(3);
    ad.show();
    ad.set();
    ad.change(5);
    ad.show();

    MinusData<int> mi;
    mi.show();
    mi.showMe();
    mi.change(6);
    ad.show();

    return 0;
}

```

<br/>
<br/>

**当在构造函数中，不使用初始化列表时（`AddData(val) {data = val;}`）输出如下：**
* Data is : 3
* Data is : 10
* Data is : 10
* 10
* Data is : 4


**当在构造函数中，使用初始化列表初始时（`AddData(val) : data(val){}`）,输出如下:**  
* Data is : 0
* Data is : 0
* Data is : 0
* 0
* Data is : -6
